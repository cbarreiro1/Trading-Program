import yfinance as yf
import alpaca_trade_api as tradeapi
import pandas as pd
import time
from message import send_text

CRYPTO_SYMBOLS = ['BTC/USD', 'ETH/USD']  # Top cryptocurrency symbols
SYMBOL_MAPPING = {
    'BTC/USD': 'BTC-USD',
    'ETH/USD': 'ETH-USD'
}
SHARES_HELD = {
    'BTC/USD': 0,
    'ETH/USD': 0
}
EMA_PERIODS = [12, 26, 9]
INTERVAL = '1m'  # Interval for price data
HISTORICAL_PERIOD = '5d'
BASE_URL = 'https://paper-api.alpaca.markets'  # Paper trading API base URL

# Alpaca API credentials (replace these with your own)
APCA_API_BASE_URL = 'https://paper-api.alpaca.markets'
APCA_API_KEY_ID = 'PK656QH6RB776NWNRDUE'
APCA_API_SECRET_KEY = 'avUl44DBTaWS7HTXhKwyR4KwARpcRQbdfzuzBdEF'

# Initialize the Alpaca API client
api = tradeapi.REST(APCA_API_KEY_ID, APCA_API_SECRET_KEY, APCA_API_BASE_URL, api_version='v2')

# Function to check if the MACD crossover happened
def is_macd_crossover(price_history):
    return price_history['MACD Line'].iloc[-2] < price_history['Signal Line'].iloc[-2] and \
           price_history['MACD Line'].iloc[-1] > price_history['Signal Line'].iloc[-1]

# Function to check if the MACD crossunder happened
def is_macd_crossunder(price_history):
    return price_history['MACD Line'].iloc[-2] > price_history['Signal Line'].iloc[-2] and \
           price_history['MACD Line'].iloc[-1] < price_history['Signal Line'].iloc[-1]

# Function to execute a buy order
def buy(symbol, quantity):
    # Check if shares are already held for the symbol
    current_quantity = SHARES_HELD[symbol]
    if current_quantity > 0:
        print('Shares of', symbol, 'are already being held. Skipping buy order.')
        return

    api.submit_order(
        symbol=symbol,
        qty=quantity,
        side='buy',
        type='market',
        time_in_force='gtc'
    )

    latest_price = price_history[symbol]['Close'].iloc[-1]  # Get the latest price for the symbol
    total_price = latest_price * quantity
    send_text(f"{quantity} share(s) of {symbol} have been bought for ${total_price:.2f}")
    SHARES_HELD[symbol] += quantity

# Function to execute a sell order
def sell(symbol, quantity):
    # Check if shares are held for the symbol
    current_quantity = SHARES_HELD[symbol]
    if current_quantity == 0:
        print('No shares of', symbol, 'are currently held. Skipping sell order.')
        return

    api.submit_order(
        symbol=symbol,
        qty=quantity,
        side='sell',
        type='market',
        time_in_force='gtc'
    )

    latest_price = price_history[symbol]['Close'].iloc[-1]  # Get the latest price for the symbol
    total_price = latest_price * quantity
    send_text(f"{quantity} share(s) of {symbol} have been sold for ${total_price:.2f}")
    SHARES_HELD[symbol] -= quantity

# Create a dictionary to store the price history for each cryptocurrency
price_history = {}

# Retrieve historical price data for each cryptocurrency
for symbol in CRYPTO_SYMBOLS:
    crypto_symbol = SYMBOL_MAPPING[symbol]  # Map the symbol to the one used by yfinance and Alpaca
    crypto = yf.Ticker(crypto_symbol)
    historical_data = crypto.history(period=HISTORICAL_PERIOD, interval=INTERVAL)
    price_history[symbol] = historical_data[['Close']].reset_index().rename(columns={'Datetime': 'Timestamp'})

while True:
    # Fetch the latest data for each cryptocurrency
    for symbol in CRYPTO_SYMBOLS:
        crypto_symbol = SYMBOL_MAPPING[symbol]  # Map the symbol to the one used by yfinance and Alpaca
        crypto_data = yf.download(crypto_symbol, period='1d', interval=INTERVAL)
        latest_price = crypto_data['Close'][-1]
        timestamp = crypto_data.index[-1]

        # Append the latest price to the price history dataframe
        price_history[symbol] = pd.concat([price_history[symbol], pd.DataFrame({'Timestamp': [timestamp], 'Close': [latest_price]})],
                                          ignore_index=True)

        # Calculate MACD line and signal line
        price_history[symbol]['MACD Line'] = price_history[symbol]['Close'].ewm(span=EMA_PERIODS[0], adjust=False).mean() - \
                                             price_history[symbol]['Close'].ewm(span=EMA_PERIODS[1], adjust=False).mean()
        price_history[symbol]['Signal Line'] = price_history[symbol]['MACD Line'].ewm(span=EMA_PERIODS[2], adjust=False).mean()

        # Check if MACD crossover happened and execute a buy order
        if is_macd_crossover(price_history[symbol]):
            buy(symbol, 1)
            print('Buy signal detected for', symbol, '. Executing buy order.')

        # Check if MACD crossunder happened and execute a sell order
        if is_macd_crossunder(price_history[symbol]):
            sell(symbol, 1)
            print('Sell signal detected for', symbol, '. Executing sell order.')

        # Print the latest values
        latest_macd = price_history[symbol]['MACD Line'].iloc[-1]
        latest_signal = price_history[symbol]['Signal Line'].iloc[-1]
        print('Latest Price for', symbol, ':', latest_price)
        print('MACD Line for', symbol, ':', latest_macd)
        print('Signal Line for', symbol, ':', latest_signal)
        print('Timestamp for', symbol, ':', timestamp)
        print()

    # Wait for the specified interval before fetching the data again
    time.sleep(60)
    